%---------------------------------------------------------
% generate a triangular grid by uniform refinement.
% 
% ne: total number of elements
% np: total number of nodes
% p:  the x- and y-coordinates of all nodes
% conn: connectivity matrix
% gbc: boundary condition indicator for all nodes
% nref>=1: number of refinement level
%---------------------------------------------------------
function [ne,np,p,conn,gbc] = gen_p1grid(nref)

% define an initial coarse mesh
ne = 4;      

x(1,1)= 0.5; y(1,1)= 0.5; efl(1,1)=0;  % 0 for inner node
x(1,2)= 1.0; y(1,2)= 0.0; efl(1,2)=1;  % 1 for Dirichlet node
x(1,3)= 1.0; y(1,3)= 1.0; efl(1,3)=1;

x(2,1)= 0.5; y(2,1)= 0.5; efl(2,1)=0;  % second element
x(2,2)= 1.0; y(2,2)= 1.0; efl(2,2)=1;
x(2,3)= 0.0; y(2,3)= 1.0; efl(2,3)=1;

x(3,1)= 0.5; y(3,1)= 0.5; efl(3,1)=0;  % third element
x(3,2)= 0.0; y(3,2)= 1.0; efl(3,2)=1;
x(3,3)= 0.0; y(3,3)= 0.0; efl(3,3)=1;

x(4,1)= 0.5; y(4,1)= 0.5; efl(4,1)=0;  % fourth element
x(4,2)= 0.0; y(4,2)= 0.0; efl(4,2)=1;
x(4,3)= 1.0; y(4,3)= 0.0; efl(4,3)=1;

% generate finer mesh based on the given coarse mesh
for i=1:nref
  nm = 0; % count the elements generated by each refinement 

  for j=1:ne   
   % mid-edge nodes of each triangle become new nodes
   x(j,4)=0.5*(x(j,1)+x(j,2)); y(j,4)=0.5*(y(j,1)+y(j,2));
   x(j,5)=0.5*(x(j,2)+x(j,3)); y(j,5)=0.5*(y(j,2)+y(j,3));
   x(j,6)=0.5*(x(j,3)+x(j,1)); y(j,6)=0.5*(y(j,3)+y(j,1));

   % generate mid-node BC indicatior from its parent 
   if (efl(j,1)==1 & efl(j,2)==1) 
       efl(j,4) = 1; 
   else
       efl(j,4)=0;   
   end 
   if (efl(j,2)==1 & efl(j,3)==1) 
       efl(j,5) = 1; 
   else
       efl(j,5)=0;      
   end
   if (efl(j,3)==1 & efl(j,1)==1) 
       efl(j,6) = 1; 
   else
       efl(j,6)=0;   
   end

  % generate four sub-elements
   nm = nm+1;   %  1st sub-element 
   xn(nm,1)=x(j,1); yn(nm,1)=y(j,1); efln(nm,1)=efl(j,1); 
   xn(nm,2)=x(j,4); yn(nm,2)=y(j,4); efln(nm,2)=efl(j,4);
   xn(nm,3)=x(j,6); yn(nm,3)=y(j,6); efln(nm,3)=efl(j,6);

   nm = nm+1;   %  2nd sub-element
   xn(nm,1)=x(j,4); yn(nm,1)=y(j,4); efln(nm,1)=efl(j,4); 
   xn(nm,2)=x(j,2); yn(nm,2)=y(j,2); efln(nm,2)=efl(j,2);
   xn(nm,3)=x(j,5); yn(nm,3)=y(j,5); efln(nm,3)=efl(j,5);

   nm = nm+1;    %  3rd sub-element
   xn(nm,1)=x(j,6); yn(nm,1)=y(j,6); efln(nm,1)=efl(j,6); 
   xn(nm,2)=x(j,5); yn(nm,2)=y(j,5); efln(nm,2)=efl(j,5);
   xn(nm,3)=x(j,3); yn(nm,3)=y(j,3); efln(nm,3)=efl(j,3);

   nm = nm+1;    %  4th sub-element
   xn(nm,1)=x(j,4); yn(nm,1)=y(j,4); efln(nm,1)=efl(j,4); 
   xn(nm,2)=x(j,5); yn(nm,2)=y(j,5); efln(nm,2)=efl(j,5);
   xn(nm,3)=x(j,6); yn(nm,3)=y(j,6); efln(nm,3)=efl(j,6);
 end % end of loop over current elements

 ne = 4*ne;  % increase the number of elements by a factor of four
 for k=1:ne     % relabel the new points
    for l=1:3
      x(k,l)=  xn(k,l);      y(k,l)=  yn(k,l);
      efl(k,l)=efln(k,l);
    end
 end
end % end of refinement loop

% get rid of redundant mid-edge nodes: 
% fix the first element, then loop the rest elements
p(1,1)=x(1,1); p(1,2)=y(1,1); gbc(1,1)=efl(1,1);
p(2,1)=x(1,2); p(2,2)=y(1,2); gbc(2,1)=efl(1,2);
p(3,1)=x(1,3); p(3,2)=y(1,3); gbc(3,1)=efl(1,3);
conn(1,1)=1;  conn(1,2)=2;  conn(1,3)=3;  

np=3;    % we already has 3 nodes from 1st element!
% loop over rest elements: Id=0 means a new node
eps = 1.0e-8;
for i=2:ne        % loop over elements
 for j=1:3          % loop over element nodes

 Id=0;
 for k=1:np
  if(abs(x(i,j)-p(k,1)) < eps & abs(y(i,j)-p(k,2)) < eps)
     Id = 1;         % indicate this node has already been used
     conn(i,j) = k;  % jth node of element i = kth global node
  end
 end

 if(Id==0)  % record the new node
   np = np+1;
   p(np,1)=x(i,j);         p(np,2)=y(i,j);
   gbc(np,1) = efl(i,j);   conn(i,j)=np;   
 end

 end
end  % end of loop over elements

return;
