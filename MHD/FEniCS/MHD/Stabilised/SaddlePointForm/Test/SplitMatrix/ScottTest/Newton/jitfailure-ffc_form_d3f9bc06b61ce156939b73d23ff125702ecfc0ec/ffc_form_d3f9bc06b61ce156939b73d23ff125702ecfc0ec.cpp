// This code conforms with the UFC specification version 2016.2.0
// and was automatically generated by FFC version 2016.2.0.
// 
// This code was generated with the following parameters:
// 
//   convert_exceptions_to_warnings: False
//   cpp_optimize:                   True
//   cpp_optimize_flags:             '-O2'
//   epsilon:                        1e-14
//   error_control:                  False
//   form_postfix:                   False
//   format:                         'ufc'
//   max_signature_length:           0
//   no-evaluate_basis_derivatives:  True
//   optimize:                       False
//   precision:                      15
//   quadrature_degree:              -1
//   quadrature_rule:                'auto'
//   representation:                 'auto'
//   split:                          False

#include "ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec.h"

// Based on https://gcc.gnu.org/wiki/Visibility
#if defined _WIN32 || defined __CYGWIN__
    #ifdef __GNUC__
        #define DLL_EXPORT __attribute__ ((dllexport))
    #else
        #define DLL_EXPORT __declspec(dllexport)
    #endif
#else
    #define DLL_EXPORT __attribute__ ((visibility ("default")))
#endif

ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_cell_integral_main_otherwise::ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_cell_integral_main_otherwise() : ufc::cell_integral()
{
    
}

ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_cell_integral_main_otherwise::~ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_cell_integral_main_otherwise()
{
    
}

const std::vector<bool> & ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_cell_integral_main_otherwise::enabled_coefficients() const
{
    static const std::vector<bool> enabled({});
    return enabled;
}

void ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_cell_integral_main_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    //   num_cells:         None
    //   quadrature_degree: 2
    //   quadrature_rule:   'default'
    //   representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    //   estimated_polynomial_degree: 2
    //   quadrature_degree:           2
    //   quadrature_rule:             'default'
    //   representation:              'quadrature'
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius of triangle in 2D
    
    
    // Array of quadrature weights.
    static const double W3[3] = {0.166666666666667, 0.166666666666667, 0.166666666666667};
    // Quadrature points on the UFC reference element: (0.166666666666667, 0.166666666666667), (0.166666666666667, 0.666666666666667), (0.666666666666667, 0.166666666666667)
    
    // Values of basis functions at quadrature points.
    static const double FE0_C0[3][3] = \
    {{-0.166666666666667, 0.166666666666667, 0.833333333333333},
    {-0.666666666666666, 0.666666666666666, 0.333333333333333},
    {-0.166666666666667, 0.166666666666667, 0.833333333333333}};
    
    static const double FE0_C0_D01[3][3] = \
    {{-1.0, 1.0, -1.0},
    {-1.0, 1.0, -1.0},
    {-1.0, 1.0, -1.0}};
    
    static const double FE0_C0_D10[3][3] = \
    {{0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0}};
    
    static const double FE0_C1[3][3] = \
    {{0.166666666666667, 0.833333333333333, 0.166666666666667},
    {0.166666666666667, 0.833333333333333, 0.166666666666667},
    {0.666666666666666, 0.333333333333333, 0.666666666666667}};
    
    static const double FE0_C1_D10[3][3] = \
    {{0.999999999999999, -0.999999999999999, 1.0},
    {0.999999999999999, -0.999999999999999, 0.999999999999999},
    {0.999999999999999, -0.999999999999999, 0.999999999999999}};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 9; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', False), ('ignore ones', False), ('ignore zero tables', False), ('optimisation', False), ('remove zero terms', False)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 1836
    for (unsigned int ip = 0; ip < 3; ip++)
    {
      
      // Number of operations for primary indices: 612
      for (unsigned int j = 0; j < 3; j++)
      {
        for (unsigned int k = 0; k < 3; k++)
        {
          // Number of operations to compute entry: 68
          A[j*3 + k] += (((((K[1]*K[0]*FE0_C0_D10[ip][j] + K[1]*K[2]*FE0_C1_D10[ip][j] + K[3]*K[0]*FE0_C0_D01[ip][j] + K[3]*K[2]*FE0_C0_D10[ip][j]))*(-1.0) + (K[0]*K[1]*FE0_C0_D10[ip][j] + K[0]*K[3]*FE0_C1_D10[ip][j] + K[2]*K[1]*FE0_C0_D01[ip][j] + K[2]*K[3]*FE0_C0_D10[ip][j])))*((((K[1]*K[0]*FE0_C0_D10[ip][k] + K[1]*K[2]*FE0_C1_D10[ip][k] + K[3]*K[0]*FE0_C0_D01[ip][k] + K[3]*K[2]*FE0_C0_D10[ip][k]))*(-1.0) + (K[0]*K[1]*FE0_C0_D10[ip][k] + K[0]*K[3]*FE0_C1_D10[ip][k] + K[2]*K[1]*FE0_C0_D01[ip][k] + K[2]*K[3]*FE0_C0_D10[ip][k]))) + (((K[0]*FE0_C0[ip][j] + K[2]*FE0_C1[ip][j]))*((K[0]*FE0_C0[ip][k] + K[2]*FE0_C1[ip][k])) + ((K[1]*FE0_C0[ip][j] + K[3]*FE0_C1[ip][j]))*((K[1]*FE0_C0[ip][k] + K[3]*FE0_C1[ip][k]))))*W3[ip]*det;
        } // end loop over 'k'
      } // end loop over 'j'
    } // end loop over 'ip'
}

extern "C" DLL_EXPORT ufc::cell_integral * create_ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_cell_integral_main_otherwise()
{
  return new ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_cell_integral_main_otherwise();
}


ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main() : ufc::form()
{
    // Do nothing
}

ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::~ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main()
{
    // Do nothing
}

const char * ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::signature() const
{
    return "93c4ae6798247893e2144d6107e5b662ac7ddfb82b309ab8ed5b822eb90322987cd1b08ba6b9d897f4d81e7c4d015fc319c116dd45c64432a40f39afb0872bff";
}

std::size_t ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::rank() const
{
    return 2;
}

std::size_t ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::num_coefficients() const
{
    return 0;
}

std::size_t ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::original_coefficient_position(std::size_t i) const
{
    static const std::vector<std::size_t> position({});
    return position[i];
}

ufc::finite_element * ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::create_coordinate_finite_element() const
{
    return create_ffc_element_8fb97a81157753ea74ad04769eb1aebe604ce903_finite_element_main();
}

ufc::dofmap * ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::create_coordinate_dofmap() const
{
    return create_ffc_element_8fb97a81157753ea74ad04769eb1aebe604ce903_dofmap_main();
}

ufc::coordinate_mapping * ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::create_coordinate_mapping() const
{
    return nullptr;
}

ufc::finite_element * ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
      {
        return create_ffc_element_1ca09c7da323f43cc9d05082aef65289352ff0a2_finite_element_main();
        break;
      }
    case 1:
      {
        return create_ffc_element_1ca09c7da323f43cc9d05082aef65289352ff0a2_finite_element_main();
        break;
      }
    }
    
    return 0;
}

ufc::dofmap * ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
      {
        return create_ffc_element_1ca09c7da323f43cc9d05082aef65289352ff0a2_dofmap_main();
        break;
      }
    case 1:
      {
        return create_ffc_element_1ca09c7da323f43cc9d05082aef65289352ff0a2_dofmap_main();
        break;
      }
    }
    
    return 0;
}

std::size_t ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::max_overlap_subdomain_id() const
{
    return 0;
}

bool ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::has_cell_integrals() const
{
    return true;
}

bool ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::has_exterior_facet_integrals() const
{
    return false;
}

bool ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::has_interior_facet_integrals() const
{
    return false;
}

bool ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::has_vertex_integrals() const
{
    return false;
}

bool ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::has_custom_integrals() const
{
    return false;
}

bool ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::has_cutcell_integrals() const
{
    return false;
}

bool ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::has_interface_integrals() const
{
    return false;
}

bool ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::create_cell_integral(std::size_t subdomain_id) const
{
    return 0;
}

ufc::exterior_facet_integral * ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return 0;
}

ufc::interior_facet_integral * ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return 0;
}

ufc::vertex_integral * ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::create_vertex_integral(std::size_t subdomain_id) const
{
    return 0;
}

ufc::custom_integral * ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::create_custom_integral(std::size_t subdomain_id) const
{
    return 0;
}

ufc::cutcell_integral * ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::create_cutcell_integral(std::size_t subdomain_id) const
{
    return 0;
}

ufc::interface_integral * ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::create_interface_integral(std::size_t subdomain_id) const
{
    return 0;
}

ufc::overlap_integral * ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::create_overlap_integral(std::size_t subdomain_id) const
{
    return 0;
}

ufc::cell_integral * ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::create_default_cell_integral() const
{
    return new ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_cell_integral_main_otherwise();
}

ufc::exterior_facet_integral * ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::create_default_exterior_facet_integral() const
{
    return 0;
}

ufc::interior_facet_integral * ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::create_default_interior_facet_integral() const
{
    return 0;
}

ufc::vertex_integral * ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::create_default_vertex_integral() const
{
    return 0;
}

ufc::custom_integral * ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::create_default_custom_integral() const
{
    return 0;
}

ufc::cutcell_integral * ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::create_default_cutcell_integral() const
{
    return 0;
}

ufc::interface_integral * ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::create_default_interface_integral() const
{
    return 0;
}

ufc::overlap_integral * ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main::create_default_overlap_integral() const
{
    return 0;
}

extern "C" DLL_EXPORT ufc::form * create_ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main()
{
  return new ffc_form_d3f9bc06b61ce156939b73d23ff125702ecfc0ec_form_main();
}

