import petsc4py
import sys

petsc4py.init(sys.argv)

from petsc4py import PETSc
import mshr
from dolfin import *
import sympy as sy
import numpy as np
import ExactSol
import MatrixOperations as MO
import CheckPetsc4py as CP
from  dolfin import __version__

def Domain(n):

    # defining the L-shaped domain
    # domain = mshr.Rectangle(Point(-1., -1.), Point(1., 1.)) - mshr.Rectangle(Point(0., -1.), Point(1., 0.) )
    # mesh = mshr.generate_mesh(domain, n)
    if __version__ == '1.6.0':
        mesh = RectangleMesh(Point(-1., -1.), Point(1., 1.),n,n)
    else:
        mesh = RectangleMesh(-1,-1,1,1,n,n, 'left')
    cell_f = CellFunction('size_t', mesh, 0)
    for cell in cells(mesh):
        v = cell.get_vertex_coordinates()
        y = v[np.arange(0,6,2)]
        x = v[np.arange(1,6,2)]
        xone = np.ones(3)
        xone[x > 0] = 0
        yone = np.ones(3)
        yone[y < 0] = 0
        if np.sum(xone)+ np.sum(yone)>5.5:
            cell_f[cell] = 1
    mesh = SubMesh(mesh, cell_f, 0)


    # cell_markers = CellFunction("bool", mesh)
    # cell_markers.set_all(False)
    # origin = Point(0., 0.)
    # for cell in cells(mesh):
    #     p = cell.midpoint()
    #     if abs(p.distance(origin)) < 0.6:
    #         cell_markers[cell] = True

    # mesh = refine(mesh, cell_markers)


    # cell_markers = CellFunction("bool", mesh)
    # cell_markers.set_all(False)
    # origin = Point(0., 0.)
    # for cell in cells(mesh):
    #     p = cell.midpoint()
    #     if abs(p.distance(origin)) < 0.4:
    #         cell_markers[cell] = True

    # mesh = refine(mesh, cell_markers)


    # cell_markers = CellFunction("bool", mesh)
    # cell_markers.set_all(False)
    # origin = Point(0., 0.)
    # for cell in cells(mesh):
    #     p = cell.midpoint()
    #     if abs(p.distance(origin)) < 0.2:
    #         cell_markers[cell] = True

    # mesh = refine(mesh, cell_markers)



    # Creating classes that define the boundary of the domain
    class Left(SubDomain):
        def inside(self, x, on_boundary):
            return near(x[0], -1.0)

    class Right(SubDomain):
        def inside(self, x, on_boundary):
            return near(x[0], 1.0)

    class Bottom(SubDomain):
        def inside(self, x, on_boundary):
            return near(x[1], -1.0)

    class Top(SubDomain):
        def inside(self, x, on_boundary):
            return near(x[1], 1.0)

    class CornerTop(SubDomain):
        def inside(self, x, on_boundary):
            return near(x[1], 0.0)

    class CornerLeft(SubDomain):
        def inside(self, x, on_boundary):
            return near(x[0], 0.0)


    left = Left()
    top = Top()
    right = Right()
    bottom = Bottom()
    cleft = CornerLeft()
    ctop = CornerTop()

    # Initialize mesh function for the domain
    domains = CellFunction("size_t", mesh)
    domains.set_all(0)

    # Initialize mesh function for boundary domains
    boundaries = FacetFunction("size_t", mesh)
    boundaries.set_all(0)

    left.mark(boundaries, 1)
    top.mark(boundaries, 1)
    bottom.mark(boundaries, 1)
    right.mark(boundaries, 1)
    cleft.mark(boundaries, 2)
    ctop.mark(boundaries, 2)
    return mesh, boundaries, domains


# functions that perform partial derivatives of x and y with respect to polar coordinates
def polarx(u, rho, phi):
    return sy.cos(phi)*sy.diff(u, rho) - (1./rho)*sy.sin(phi)*sy.diff(u, phi)

def polary(u, rho, phi):
    return sy.sin(phi)*sy.diff(u, rho) + (1./rho)*sy.cos(phi)*sy.diff(u, phi)

def polarr(u, x, y):
    return (1./sqrt(x**2 + y**2))*(x*sy.diff(u,x)+y*sy.diff(u,y))

def polart(u, x, y):
    return -y*sy.diff(u,x)+x*sy.diff(u,y)

def SolutionSetUp():
    tic()
    l = 0.54448373678246
    omega = (3./2)*np.pi

    z = sy.symbols('z')

    x = sy.symbols('x[0]')
    y = sy.symbols('x[1]')
    rho = sy.sqrt(x**2 + y**2)
    phi = sy.atan2(y,x)

    # looked at all the exact solutions and they seems to be the same as the paper.....
    psi = (sy.sin((1+l)*phi)*sy.cos(l*omega))/(1+l) - sy.cos((1+l)*phi) - (sy.sin((1-l)*phi)*sy.cos(l*omega))/(1-l) + sy.cos((1-l)*phi)

    psi_prime = polart(psi, x, y)
    psi_3prime = polart(polart(psi_prime, x, y), x, y)

    u = rho**l*((1+l)*sy.sin(phi)*psi + sy.cos(phi)*psi_prime)
    v = rho**l*(-(1+l)*sy.cos(phi)*psi + sy.sin(phi)*psi_prime)

    uu0 = Expression((sy.ccode(u),sy.ccode(v)))
    ub0 = Expression((str(sy.ccode(u)).replace('atan2(x[1], x[0])','(atan2(x[1], x[0])+2*pi)'),str(sy.ccode(v)).replace('atan2(x[1], x[0])','(atan2(x[1], x[0])+2*pi)')))

    p = -rho**(l-1)*((1+l)**2*psi_prime + psi_3prime)/(1-l)
    pu0 = Expression(sy.ccode(p))
    pb0 = Expression(str(sy.ccode(p)).replace('atan2(x[1], x[0])','(atan2(x[1], x[0])+2*pi)'))

    f = rho**(2./3)*sy.sin((2./3)*phi)
    b = sy.diff(f,x)
    d = sy.diff(f,y)
    bu0 = Expression((sy.ccode(b),sy.ccode(d)))
    bb0 = Expression((str(sy.ccode(b)).replace('atan2(x[1], x[0])','(atan2(x[1], x[0])+2*pi)'),str(sy.ccode(d)).replace('atan2(x[1], x[0])','(atan2(x[1], x[0])+2*pi)')))

    r = sy.diff(x,y)
    ru0 = Expression(sy.ccode(r))

    #Laplacian
    L1 = sy.diff(u,x,x)+sy.diff(u,y,y)
    L2 = sy.diff(v,x,x)+sy.diff(v,y,y)

    A1 = u*sy.diff(u,x)+v*sy.diff(u,y)
    A2 = u*sy.diff(v,x)+v*sy.diff(v,y)

    P1 = sy.diff(p,x)
    P2 = sy.diff(p,y)


    # Curl-curl
    C1 = sy.diff(d,x,y) - sy.diff(b,y,y)
    C2 = sy.diff(b,x,y) - sy.diff(d,x,x)

    R1 = sy.diff(r,x)
    R2 = sy.diff(r,y)


    NS1 = -d*(sy.diff(d,x)-sy.diff(b,y))
    NS2 = b*(sy.diff(d,x)-sy.diff(b,y))

    M1 = sy.diff(u*d-v*b,y)
    M2 = -sy.diff(u*d-v*b,x)
    print '                                             ', toc()
    tic()
    Laplacian = Expression((sy.ccode(L1),sy.ccode(L2)))
    Advection = Expression((sy.ccode(A1),sy.ccode(A2)))
    gradPres = Expression((sy.ccode(P1),sy.ccode(P2)))
    CurlCurl = Expression((sy.ccode(C1),sy.ccode(C2)))
    gradR = Expression((sy.ccode(R1).replace('M_PI','pi'),sy.ccode(R2).replace('M_PI','pi')))
    NS_Couple = Expression((sy.ccode(NS1),sy.ccode(NS2)))
    M_Couple = Expression((sy.ccode(M1),sy.ccode(M2)))
    print '                                             ', toc()

    return uu0, ub0, pu0, pb0, bu0, bb0, ru0, Laplacian, Advection, gradPres, CurlCurl, gradR, NS_Couple, M_Couple



def SolutionMeshSetup(mesh, params,uu0, ub0, pu0, pb0, bu0, bb0, ru0, Laplacian, Advection, gradPres, CurlCurl, gradR, NS_Couple, M_Couple):


    class u0(Expression):
        def __init__(self, mesh, uu0, ub0):
            self.mesh = mesh
            self.u0 = uu0
            self.b0 = ub0
        def eval_cell(self, values, x, ufc_cell):
            if abs(x[0]) < 1e-2 and abs(x[1]) < 1e-2:
                values[0] = 0.0
                values[1] = 0.0
            else:
                if x[1] < 0:
                    values[0] = self.b0(x[0], x[1])[0]
                    values[1] = self.b0(x[0], x[1])[1]
                else:
                    values[0] = self.u0(x[0], x[1])[0]
                    values[1] = self.u0(x[0], x[1])[1]
        def value_shape(self):
            return (2,)

    class p0(Expression):
        def __init__(self, mesh, pu0, pb0):
            self.mesh = mesh
            self.p0 = pu0
            self.b0 = pb0
        def eval_cell(self, values, x, ufc_cell):
            if abs(x[0]) < 1e-2 and abs(x[1]) < 1e-2:
                values[0] = 0.0
            else:
                if x[1] < 0:
                    values[0] = self.b0(x[0], x[1])
                else:
                    values[0] = self.p0(x[0], x[1])

    class b0(Expression):
        def __init__(self, mesh, bu0, bb0):
            self.mesh = mesh
            self.b0 = bu0
            self.bb0 = bb0
        def eval_cell(self, values, x, ufc_cell):
            if abs(x[0]) < 1e-2 and abs(x[1]) < 1e-2:
                values[0] = 0.0
                values[1] = 0.0
            else:
                if x[1] < 0:
                    values[0] = self.bb0(x[0], x[1])[0]
                    values[1] = self.bb0(x[0], x[1])[1]
                else:
                    values[0] = self.b0(x[0], x[1])[0]
                    values[1] = self.b0(x[0], x[1])[1]
                # print values
        def value_shape(self):
            return (2,)

    class r0(Expression):
        def __init__(self, mesh, element=None):
            self.mesh = mesh
        def eval(self, values, x):
            values[0] = 1.0

    u0 = u0(mesh, uu0, ub0)
    p0 = p0(mesh, pu0, pb0)
    b0 = b0(mesh, bu0, bb0)
    r0 = r0(mesh)

    return u0, p0, b0, r0







# Sets up the initial guess for the MHD problem
def Stokes(V, Q, F, u0, p0, gradu0, params,boundaries, domains):
    parameters['reorder_dofs_serial'] = False

    W = V*Q
    IS = MO.IndexSet(W)
    mesh = W.mesh()
    ds = Measure('ds', domain=mesh, subdomain_data=boundaries)
    dx = Measure('dx', domain=mesh)
    (u, p) = TrialFunctions(W)
    (v, q) = TestFunctions(W)
    n = FacetNormal(W.mesh())

    a11 = params[2]*inner(grad(v), grad(u))*dx('everywhere')
    a12 = -div(v)*p*dx('everywhere')
    a21 = -div(u)*q*dx('everywhere')
    a = a11+a12+a21

    L = inner(v, F)*dx('everywhere') #+ inner(gradu0,v)*ds(2)

    def boundary(x, on_boundary):
        return on_boundary

    bcu = DirichletBC(W.sub(0), u0, boundary)

    A, b = assemble_system(a, L, bcu)
    A, b = CP.Assemble(A, b)
    # print b.array
    # sss
    u = b.duplicate()

    ksp = PETSc.KSP()
    ksp.create(comm=PETSc.COMM_WORLD)
    pc = ksp.getPC()
    ksp.setType('preonly')
    pc.setType('lu')
    OptDB = PETSc.Options()
    if __version__ != '1.6.0':
        OptDB['pc_factor_mat_solver_package']  = "mumps"
    OptDB['pc_factor_mat_ordering_type']  = "rcm"
    ksp.setFromOptions()
    # print b.array
    # bbb
    scale = b.norm()
    b = b/scale
    ksp.setOperators(A,A)
    del A
    ksp.solve(b,u)
    # Mits +=dodim
    u = u*scale
    u_k = Function(V)
    p_k = Function(Q)
    u_k.vector()[:] = u.getSubVector(IS[0]).array
    p_k.vector()[:] = u.getSubVector(IS[1]).array
    ones = Function(Q)
    ones.vector()[:]=(0*ones.vector().array()+1)
    p_k.vector()[:] += -assemble(p_k*dx('everywhere'))/assemble(ones*dx('everywhere'))
    return u_k, p_k


def Maxwell(V, Q, F, b0, r0, params,boundaries):
    parameters['reorder_dofs_serial'] = False

    W = V*Q
    IS = MO.IndexSet(W)

    mesh = W.mesh()

    (b, r) = TrialFunctions(W)
    (c, s) = TestFunctions(W)

    a11 = params[1]*params[2]*inner(curl(b), curl(c))*dx('everywhere')
    a21 = inner(b,grad(s))*dx('everywhere')
    a12 = inner(c,grad(r))*dx('everywhere')
    L = inner(c, F)*dx('everywhere')
    a = a11+a12+a21

    def boundary(x, on_boundary):
        return on_boundary

    bcbOuter = DirichletBC(W.sub(0), b0, boundaries, 1)
    bcbInner = DirichletBC(W.sub(0), Expression(('0.0','0.0')), boundaries, 2)
    bcr = DirichletBC(W.sub(1), r0, boundary)
    bc = [bcbOuter, bcbInner, bcr]

    A, b = assemble_system(a, L, bc)

    A, b = CP.Assemble(A, b)
    u = b.duplicate()

    ksp = PETSc.KSP()
    ksp.create(comm=PETSc.COMM_WORLD)
    pc = ksp.getPC()
    ksp.setType('preonly')
    pc.setType('lu')
    OptDB = PETSc.Options()
    if __version__ != '1.6.0':
        OptDB['pc_factor_mat_solver_package']  = "mumps"
    OptDB['pc_factor_mat_ordering_type']  = "rcm"
    ksp.setFromOptions()
    scale = b.norm()
    b = b/scale
    ksp.setOperators(A,A)
    del A
    ksp.solve(b,u)
    u = u*scale

    u_k = Function(V)
    p_k = Function(Q)
    u_k.vector()[:] = u.getSubVector(IS[0]).array
    p_k.vector()[:] = u.getSubVector(IS[1]).array

    return u_k, p_k



def Errors(X,mesh,FSpaces,ExactSolution,k,dim):

    Vdim = dim[0]
    Pdim = dim[1]
    Mdim = dim[2]
    Rdim = dim[3]
    # k +=2
    VelocityE = VectorFunctionSpace(mesh,"CG",5)
    u = interpolate(ExactSolution[0],VelocityE)

    PressureE = FunctionSpace(mesh,'CG',4)
    # parameters["form_compiler"]["quadrature_degree"] = 8
    # X = x.array()
    xu = X[0:Vdim]
    ua = Function('CG'paces[0])
    ua.vector()[:] = xu

    pp = X[Vdim:Vdim+Pdim]


    pa = Function('CG'paces[1])
    pa.vector()[:] = pp

    pend = assemble(pa*dx)

    ones = Function(FSpaces[1])
    ones.vector()[:]=(0*pp+1)
    pp = Function(FSpaces[1])
    pp.vector()[:] = pa.vector().array()- assemble(pa*dx)/assemble(ones*dx)

    pInterp = interpolate(ExactSolution[1],PressureE)
    pe = Function(PressureE)
    pe.vector()[:] = pInterp.vector().array()
    const = - assemble(pe*dx)/assemble(ones*dx)
    pe.vector()[:] = pe.vector()[:]+const

    ErrorU = Function(FSpaces[0])
    ErrorP = Function(FSpaces[1])

    ErrorU = u-ua
    ErrorP = pe-pp
    errL2u= sqrt(abs(assemble(inner(ErrorU, ErrorU)*dx)))
    errH1u= sqrt(abs(assemble(inner(grad(ErrorU), grad(ErrorU))*dx)))
    errL2p= sqrt(abs(assemble(inner(ErrorP, ErrorP)*dx)))
    # parameters["form_compiler"]["quadrature_degree"] = -1

    MagneticE = FunctionSpace(mesh,"N1curl",4)
    LagrangeE = FunctionSpace(mesh,"CG",4)
    b = interpolate(ExactSolution[2],MagneticE)
    r = interpolate(ExactSolution[3],LagrangeE)


    xb = X[Vdim+Pdim:Vdim+Pdim+Mdim]
    ba = Function(FSpaces[2])
    ba.vector()[:] = xb

    xr = X[Vdim+Pdim+Mdim:]
    ra = Function(FSpaces[3])
    ra.vector()[:] = xr


    ErrorB = Function(FSpaces[2])
    ErrorR = Function(FSpaces[3])


    ErrorB = b-ba
    ErrorR = r-ra
    print '               Exact solution curl   ', assemble(curl(b)*dx), '    assemble(curl(b)*dx)'
    print '               Approx solution curl  ', assemble(curl(ba)*dx), '    assemble(curl(ba)*dx)'
    print '               Error curl            ', assemble(curl(ErrorB)*dx), '    assemble(curl(ErrorB)*dx)'
    print '               Error curl-curl       ', assemble(curl(ErrorB)*curl(ErrorB)*dx), '    assemble(curl(ErrorB)*curl(ErrorB)*dx)'
    print '               Error inner curl-curl ', assemble(inner(curl(ErrorB),curl(ErrorB))*dx), '    assemble(inner(curl(ErrorB),curl(ErrorB))*dx)'
    # errL2b= sqrt(abs(assemble(inner(ErrorB, ErrorB)*dx)))
    # errCurlb = sqrt(abs(assemble(curl(ErrorB)*curl(ErrorB)*dx)))
    # errL2r= sqrt(abs(assemble(inner(ErrorR, ErrorR)*dx)))
    # errH1r= sqrt(abs(assemble(inner(grad(ErrorR), grad(ErrorR))*dx)))


    errL2b= errornorm(b, ba, norm_type='L2', degree_rise=8)
    errCurlb = errornorm(b, ba, norm_type='Hcurl0', degree_rise=8)
    errL2r= errornorm(r, ra, norm_type='L2', degree_rise=8)
    errH1r= errornorm(r, ra, norm_type='H10', degree_rise=8)

    return errL2u, errH1u, errL2p, errL2b, errCurlb, errL2r, errH1r














