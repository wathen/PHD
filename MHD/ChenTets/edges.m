function [Te, Be, edge_ind] = edges(T,E)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Anna S., 4.10.02
%
% this function numbers the edges of a triangular mesh 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% The input parameter is the element-list T, as generated by the PDE-toolbox-command 'initmesh'
% (for description type 'help initmesh' in the MATLAB command-window). In fact, we only need the first 3 rows
% of T.
%
% The output parameters are the total number of edges edge_ind, the matrix
% Te containing the edge data and the vector Be containing the indices of
% the boundary-edges.
% The structure of Te is similar to the structure of T: the 3 first rows of Te contain the global edge-numbers of
% the elements (each column of Te represents an element). Locally on an element, the edges are numbered couterclockwise, 
% starting with the one between the local vertices 1 and 2. The 3 last rows of Te endow the edges with an orientation,
% which is set to plus or minus one. 
% 
% The numbering is straight-forward and not sophisticated at all; we cannot expect the non-zero entries of the 
% global stiffness-matrix A to be disributed in a regular pattern. This can affect the condition number of A and the
% memory requirement in a negative way.
% 
%
% Accelerated version: October 02


disp('computing edge data...')
pause(0.001)        % this is just a hack to force MATLAB to display the previous command immediately



el_num = length(T);        % number of elements
edge_ind = 0;               % edge-index
Te = zeros(6,el_num);      % number of edges are 3 per element (+3 rows for edge-orientation)
Be = [];                % initialize boundary edge vector
be_num = length(E);        % number of boundary edges


% loop over all elements
for l=1:el_num
% loop over edges of element
for e=1:3
    
    % if edge is not yet numbered...
    if Te(e,l)== 0 
        % number edge
        edge_ind = edge_ind + 1;
        Te(e,l) = edge_ind;
        % give orientation +1
        Te(e+3,l) = 1;
        
        % get global number of start- and end-point
        Ps = T(e,l);
        Pe = T(mod(e,3)+1,l);
        
        %% forward-search for other element containing this edge %%
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        stop = 0;                % control variable to stop the numbering if other edge is found
        for ol = l+1 : el_num
            for Ps_local = 1 : 3
                if ( ~(T(Ps_local,ol)-Ps) | ~(T(Ps_local,ol)-Pe) )    % start- or end-point are in element ol
                    
                    for Pe_local = (Ps_local+1) : 3
                       if ( ~(T(Pe_local,ol)-Ps) | ~(T(Pe_local,ol)-Pe) ) 
                           % other edge between local pts Ps_local and Pe_local
                           oe_local = Ps_local + Pe_local;
                           switch oe_local
                           case 3 
                            % edge between local pts 1 and 2
                            Te(1,ol) = edge_ind;
                            Te(4,ol) = -1;
                           case 5
                            % edge between local pts 2 and 3
                            Te(2,ol) = edge_ind;
                            Te(5,ol) = -1;
                           case 4
                            % edge between local pts 3 and 1
                            Te(3,ol) = edge_ind;
                            Te(6,ol) = -1;
                           end
                           stop = 1;        % other edge is found and we can stop this nested loop
                       end  % if
                   end  % for Pe_local
               end  % if
           end % for Ps_local
           
           if(stop)         % leave outer loop, since there is at most 1 other element containing e as edge
                break    
           end
               
           end  % for ol
           
           %%% In order to have an easy access to boundary edges, we flag them here %%%
           
           for be = 1 : be_num      % loop over all boundary edges
               
               % check if current edge is a boundary edge
               if( (~(E(1,be)-Ps) | ~(E(1,be)-Pe) ) & (~(E(2,be)-Ps) | ~(E(2,be)-Pe) ) )
                   
                   %check, if this edge is on \emph{outer} boundary
                   
                    if E(6,be) | E(7,be)
                        
                        % label this edge as Dirichlet boundary edge
                        Be = [Be edge_ind];
               
                    end % if
                    break       % edge flagged as boundary edge, exit loop over boundary edges.
                end % if
                
            end % for be

        
    end % if
end % for e
end %for l


return
        
        
            







